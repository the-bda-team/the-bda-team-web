<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>BibTeX to BDA Publications JSON</title>
<script src="https://cdn.jsdelivr.net/npm/bib2json@0.0.1/Parser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@json-editor/json-editor@latest/dist/jsoneditor.min.js"></script>
</head>
<body>

<textarea id="bibtex" rows="15" cols="80" placeholder="Paste BibTeX here..."></textarea>
<br><br>
<button id="convert">Convert to JSON</button>

<div id="editor_holder"></div>

<button id="submit">Get JSON from Form</button>
<button id="fill">Fill Form with Sample Data</button>

<pre id="output"></pre>

<script>
let editor = null;

Promise.all([
  fetch("https://raw.githubusercontent.com/the-bda-team/the-bda-team-web/refs/heads/main/_schemas/publications.json"),
  fetch("https://raw.githubusercontent.com/the-bda-team/the-bda-team-web/refs/heads/main/_schemas/base.json")
]).then(async ([publicationRes, baseRes]) => {
  const publicationSchema = await publicationRes.json();
  const baseSchema = await baseRes.json();

  // 1. Initialize the Editor
  const element = document.getElementById('editor_holder');
  editor = new JSONEditor(element, {
    ajax: true,
    schema: publicationSchema,
    refs: {
      "_schemas/base.json": baseSchema
    },
    disable_collapse: true,
    disable_edit_json: true,
    disable_properties: true
  });
});

// 2. Function to get JSON object (Submit)
document.getElementById('submit').addEventListener('click', () => {
  const errors = editor.validate();
  if (errors.length) {
    console.log("Validation Errors:", errors);
  } else {
    const data = editor.getValue();
    console.log("Created JSON:", data);
    alert(JSON.stringify(data, null, 2));
  }
});


document.getElementById("convert").onclick = () => {
  const input = document.getElementById("bibtex").value.trim();
  if (!input) {
    alert("Paste a BibTeX string first!");
    return;
  }

  let entries;
  try {
    entries = BibtexParser(input).entries;
  } catch (e) {
    console.error(e);
    alert("BibTeX parsing failed.");
    return;
  }

  console.log(entries)
  const results = [];

  for (const e of entries) {
    let category;

    switch (e.EntryType.toLowerCase()) {
      case "inproceedings":
        category = "InProceedings";
        break;
      case "article":
        category = "Article";
        break;
      case "phdthesis":
        category = "PhDThesis";
        break;
      default:
        console.warn("Unsupported BibTeX type:", e.EntryType);
        continue;
    }

    const out = {
      id: e.EntryKey.toLowerCase().replace("20",":20") || "",
      category,
      title: e.Fields.title || "",
      year: e.Fields.year ? parseInt(e.Fields.year, 10) : null,
      month: (e.Fields.month) ? e.Fields.month.substring(0, 3).toLowerCase() : null,
      author: parseAuthors(e.Fields.author || "")
    };

    // Common optional fields
    if (e.Fields.doi)  out.doi = e.Fields.doi;
    if (e.Fields.url)  out.url = e.Fields.url;
    if (e.Fields.isbn) out.isbn = e.Fields.isbn;
    if (e.Fields.issn) out.issn = e.Fields.issn;

    // Type-specific mappings
    if (category === "InProceedings") {
      if (e.Fields.booktitle) out.booktitle = e.Fields.booktitle;
      if (e.Fields.editor) out.editor = parseAuthors(e.Fields.editor);
      if (e.Fields.publisher) out.publisher = e.Fields.publisher;
      if (e.Fields.organization) out.organization = e.Fields.organization;
      if (e.Fields.series) out.series = e.Fields.series;
      if (e.Fields.volume) out.volume = e.Fields.volume;
      if (e.Fields.pages) out.pages = normalizePages(e.Fields.pages);
    }

    if (category === "Article") {
      if (e.Fields.journal) out.journal = e.Fields.journal;
      if (e.Fields.volume) out.volume = e.Fields.volume;
      if (e.Fields.number) out.number = parseInt(e.Fields.number, 10);
      if (e.Fields.publisher) out.publisher = e.Fields.publisher;
    }

    if (category === "PhDThesis") {
      if (e.Fields.school) out.school = e.Fields.school;
    }

    results.push(out);
  }

  editor.setValue(results);
};

function parseAuthors(authorField) {
  if (!authorField) return [];

  return authorField
    .split(/\s+and\s+/i)
    .map(name => {
      name = name.trim();

      // Handle "Last, First"
      if (name.includes(",")) {
        return name.split(",").map(s => s.trim());
      }

      // Handle "First Last"
      const parts = name.split(/\s+/);
      return [
        parts.slice(0, -1).join(" "),
        parts.slice(-1)[0]
      ];
    });
}

function normalizePages(pages) {
  // BibTeX schema expects double dash
  return pages.replace(/-/g, "--");
}
</script>

</body>
</html>
